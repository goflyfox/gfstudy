# 第八章 GoFrame配置文件

## 8.1 配置介绍

`GoFrame` 的配置管理由 `gcfg` 组件实现， `gcfg` 组件的所有方法是并发安全的。 `gcfg` 组件采用接口化设计，默认提供的是基于文件系统的接口实现。

## 组件特性

`gcfg` 组件具有以下显著特性：

- 接口化设计，很高的灵活性及扩展性，默认提供文件系统接口实现
- 支持多种常见配置文件格式： `yaml/toml/json/xml/ini/properties`
- 支持配置项不存在时读取指定环境变量或命令行参数
- 支持检索读取资源管理组件中的配置文件
- 支持配置文件自动检测热更新特性
- 支持层级访问配置项
- 支持单例管理模式

## 注意事项

框架配置组件支持多种常用的数据格式，但在后续的示例代码中均使用 `yaml` 数据格式来做演示说明。在使用中，请随意使用习惯的数据格式 **不用局限于官网示例使用的 `yaml` 数据格式**。例如，在业务项目模板中提供的是 `config.yaml` 配置文件模板（因为默认模板只能提供一种啊），您也可以直接修改为 `config.toml` 或者 `config.ini` 等支持的数据格式， **配置组件也能自动根据文件名后缀识别读取**。

## 8.2 自动检测更新

配置管理器使用了缓存机制，当配置文件第一次被读取后会被缓存到内存中，下一次读取时将会直接从缓存中获取，以提高性能。同时，配置管理器提供了对配置文件的**自动检测更新机制**，当配置文件在外部被修改后，配置管理器能够即时地刷新配置文件的缓存内容。

配置管理器的自动检测更新机制是`gf`框架特有的一大特色。

## 8.3 示例

### 项目目录

```bash
D:.
│  config_test.go -- 测试文件
│  go.mod
│  go.sum
│  main.go -- web自动更新配置演示
│
├─config
│      config.yaml -- 标准配置文件
│
└─configTest -- 定制目录和配置文件
        config1.yaml  
        config2.yaml
```

### config.yaml

```yaml
viewpath: /home/www/templates/ # 模板引擎目录
name: hello world!
database: # MySQL数据库配置
  default:
    - host: 127.0.0.1
      port: "3306"
      user: root
      pass: "123456"
      name: test1
      type: mysql
      role: master
      charset: utf8
      priority: "1"
    - host: 127.0.0.1
      port: "3306"
      user: root
      pass: "123456"
      name: test2
      type: mysql
      role: master
      charset: utf8
      priority: "1"
redis: # Redis数据库配置
  disk: 127.0.0.1:6379,0
  cache: 127.0.0.1:6379,1
```

### config1.toml

```yaml
study: "hello study"
study1: "hello study1"
```

### config2.toml

```yaml
config2: "111"
```

### main.go

```go
package main

import (
	"github.com/gogf/gf/v2/frame/g"
	"github.com/gogf/gf/v2/net/ghttp"
)

func main() {
	s := g.Server()
	// 默认路径
	s.BindHandler("/", func(r *ghttp.Request) {
		name, err := g.Cfg().Get(r.GetCtx(), "name")
		if err != nil {
			r.Response.Writeln(err.Error())
			r.Exit()
		}
		r.Response.Writeln("配置", name)
		r.Response.Writeln("Welcome GoFrame!")
	})

	s.SetPort(8199)
	s.Run()

}
```

### config_test.go

```go
package main

import (
	"fmt"
	"github.com/gogf/gf/v2/frame/g"
	"github.com/gogf/gf/v2/os/gcfg"
	"github.com/gogf/gf/v2/os/gctx"
	"testing"
)

// 基本配置使用
func TestConfig(t *testing.T) {
	ctx := gctx.New()
	// 默认当前路径或者config路径，默认文件config.yaml
	// /home/www/template/
	fmt.Println(g.Config().Get(ctx, "viewpath"))
	fmt.Println(g.Cfg().Get(ctx, "viewpath"))
	// 127.0.0.1:6379,1
	c := g.Cfg()
	// 分组方式
	fmt.Println(c.Get(ctx, "redis.cache"))
	// 数组方式：test2
	fmt.Println(c.Get(ctx, "database.default.1.name"))
}

// 设置路径
func TestConfig2(t *testing.T) {
	ctx := gctx.New()
	// 设置加载文件，默认name为default
	// 设置路径
	g.Cfg().GetAdapter().(*gcfg.AdapterFile).SetPath("configTest")
	// 设置加载文件
	g.Cfg().GetAdapter().(*gcfg.AdapterFile).SetFileName("config1.yaml")

	// 打印测试
	fmt.Println(g.Cfg().Get(ctx, "viewpath"))
	fmt.Println(g.Cfg().Get(ctx, "study"))
	fmt.Println(g.Cfg().Get(ctx, "study1"))
	fmt.Println(g.Cfg().Get(ctx, "config2"))

	// 新的name就是新的实例
	g.Cfg("name").GetAdapter().(*gcfg.AdapterFile).SetPath("configTest")
	g.Cfg("name").GetAdapter().(*gcfg.AdapterFile).SetFileName("config2.yaml")
	fmt.Println(g.Cfg("name").Get(ctx, "viewpath"))
	fmt.Println(g.Cfg("name").Get(ctx, "study"))
	fmt.Println(g.Cfg("name").Get(ctx, "study1"))
	fmt.Println(g.Cfg("name").Get(ctx, "config2"))
}
```

### go.mod

```go
module gf_config

go 1.21

require github.com/gogf/gf/v2 v2.9.0
```

