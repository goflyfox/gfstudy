# 第六章 GoFrame中间件

## 6.1 中间件设计

`GoFrame` 提供了优雅的中间件请求控制方式， 该方式也是主流的 `WebServer` 提供的请求流程控制方式， 基于中间件设计可以为 `WebServer` 提供更灵活强大的插件机制。经典的中间件洋葱模型：

![经典的中间件洋葱模型](04.goframe路由注册.assets/middleware.png)

### 6.1.1 中间件定义

中间件的定义和普通HTTP执行方法 `HandlerFunc` 一样，但是可以在 `Request` 参数中使用 `Middleware` 属性对象来控制请求流程。

### 6.1.2 中间件类型

中间件的类型分为两种：前置中间件和后置中间件。前置即在路由服务函数调用之前调用，后置即在其后调用。

其定义类似于：

```go
func Middleware(r *ghttp.Request) {
    // 前置中间件：处理逻辑
    r.Middleware.Next()
    // 后置中间件：处理逻辑
}
```

### 6.1.3 全局中间件注册

```go
func (s *Server) Use(handlers ...HandlerFunc)
```

全局中间件是可以 **独立使用** 的请求拦截方法，通过路由规则的方式进行注册，绑定到 `Server` 上，由于中间件需要执行请求拦截操作，因此往往是使用"模糊匹配"或者"命名匹配"规则。

### 6.1.4 分组路由中间件

```go
func (g *RouterGroup) Middleware(handlers ...HandlerFunc) *RouterGroup
```

分组路由中注册的中间件绑定到当前分组路由中的所有的服务请求上，当服务请求被执行前会调用到其绑定的中间件方法。 分组路由仅有一个 `Middleware` 的中间件注册方法。分组路由中间件与全局中间件不同之处在于， **分组路由中间件无法独立使用**，必须在分组路由注册中使用，并且绑定到当前分组路由中所有的路由上作为路由方法的一部分。

### 6.1.5 执行优先级

由于全局中间件也是通过路由规则执行，那么也会存在执行优先级：

1. 首先，由于全局中间件是基于模糊路由匹配，因此 **当同一个路由匹配到多个中间件时，会按照路由的深度优先规则执行**，具体请查看路由章节；
2. 其次， **同一个路由规则下，会按照中间件的注册先后顺序执行**，中间件的注册方法也支持同时按照先后顺序注册多个中间件；
3. 最后，为避免优先级混淆和后续管理，建议将所有中间件放到同一个地方进行先后顺序注册来控制执行优先级；

示例：

```go
    // 分组注册及中间件
	group := s.Group("/api")
	group.Middleware(MiddlewareTest)
	group.ALL("/all", func(r *ghttp.Request) {
		r.Response.Writeln("all")
	})
```

## 6.2 教程示例

```go
package main

import (
	"context"
	"github.com/gogf/gf/v2/frame/g"
	"github.com/gogf/gf/v2/net/ghttp"
)

type HelloReq struct {
	g.Meta `path:"/hello" method:"get"`
}
type HelloRes struct {
}

type Hello struct{}

func (Hello) Say(ctx context.Context, req *HelloReq) (res *HelloRes, err error) {
	g.Log().Info(ctx, "中")
	return
}

func RequestHandle1(r *ghttp.Request) {
	g.Log().Info(r.GetCtx(), "前1")
	r.Middleware.Next()
}

func RequestHandle2(r *ghttp.Request) {
	g.Log().Info(r.GetCtx(), "前2")
	r.Middleware.Next()
}

func RequestHandle3(r *ghttp.Request) {
	g.Log().Info(r.GetCtx(), "前3")
	r.Middleware.Next()
}

func RequestHandle4(r *ghttp.Request) {
	g.Log().Info(r.GetCtx(), "前4")
	r.Middleware.Next()
}

func ResponseHandle1(r *ghttp.Request) {
	r.Middleware.Next()
	g.Log().Info(r.GetCtx(), "后1")
}

func ResponseHandle2(r *ghttp.Request) {
	r.Middleware.Next()
	g.Log().Info(r.GetCtx(), "后2")
}

func ResponseHandle3(r *ghttp.Request) {
	r.Middleware.Next()
	g.Log().Info(r.GetCtx(), "后3")
}

func ResponseHandle4(r *ghttp.Request) {
	r.Middleware.Next()
	g.Log().Info(r.GetCtx(), "后4")
}

func main() {
	s := g.Server()
	s.Use(ghttp.MiddlewareHandlerResponse)
	s.Group("/", func(group *ghttp.RouterGroup) {
		// 前置中间件
		group.Middleware(RequestHandle1)
		group.Middleware(RequestHandle2)

		// 后置中间件
		group.Middleware(ResponseHandle1)
		group.Middleware(ResponseHandle2)

		group.Group("/sub", func(group *ghttp.RouterGroup) {
			// 前置中间件
			group.Middleware(RequestHandle3)
			group.Middleware(RequestHandle4)

			// 后置中间件
			group.Middleware(ResponseHandle3)
			group.Middleware(ResponseHandle4)

			group.Bind(new(Hello))
		})
	})
	s.Run()
}

```

访问结果：

```go
### 中间件
GET http://localhost:8199/sub/hello
```

